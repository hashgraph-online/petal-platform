{
  "name": "@hol-org/petal-platform",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "predev": "pnpm run setup:hcs2-topics -- --skip-if-missing-creds",
    "dev": "next dev --webpack",
    "build": "next build --webpack",
    "start": "next start",
    "preview": "opennextjs-cloudflare build && opennextjs-cloudflare preview",
    "deploy": "opennextjs-cloudflare build && opennextjs-cloudflare deploy",
    "cf:build": "next build --webpack && node -e \"const fs=require('node:fs'); const path=require('node:path'); const root=process.cwd(); const srcNext=path.join(root,'.next'); const dstNext=path.join(root,'.next','standalone','.next'); const copy=(src,dst)=>{ if(!fs.existsSync(src)) return; fs.mkdirSync(path.dirname(dst),{recursive:true}); fs.copyFileSync(src,dst); }; copy(path.join(srcNext,'BUILD_ID'), path.join(dstNext,'BUILD_ID')); for (const name of fs.readdirSync(srcNext)) { if (name.endsWith('.json')) copy(path.join(srcNext,name), path.join(dstNext,name)); } const srcServer=path.join(srcNext,'server'); const dstServer=path.join(dstNext,'server'); for (const name of fs.readdirSync(srcServer)) { if (name.endsWith('.json') || name.endsWith('-manifest.js')) copy(path.join(srcServer,name), path.join(dstServer,name)); } const srcApp=path.join(srcServer,'app'); const walk=(dir)=>{ for (const entry of fs.readdirSync(dir,{withFileTypes:true})) { const abs=path.join(dir,entry.name); if(entry.isDirectory()) walk(abs); else if(entry.isFile() && entry.name.endsWith('_client-reference-manifest.js')) { const rel=path.relative(srcNext,abs); copy(abs, path.join(dstNext, rel)); } } }; if(fs.existsSync(srcApp)) walk(srcApp);\" && opennextjs-cloudflare build --skipNextBuild && node -e \"const fs=require('node:fs'); const path=require('node:path'); const root=process.cwd(); const indexFile=path.join(root,'.open-next','server-functions','default','index.mjs'); if(fs.existsSync(indexFile)) { const src=fs.readFileSync(indexFile,'utf8'); if(!src.includes('getMiddlewareManifestPatched')) { const needle='import NextServer from \\\"next/dist/server/next-server.js\\\";'; const idx=src.indexOf(needle); if(idx<0) { console.error('OpenNext patch target not found'); process.exit(1); } const insert='\\n\\nconst NextNodeServerPatched = NextServer?.default ?? NextServer;\\nif (NextNodeServerPatched?.prototype && typeof NextNodeServerPatched.prototype.getMiddlewareManifest === \\\"function\\\") {\\n  NextNodeServerPatched.prototype.getMiddlewareManifest = function getMiddlewareManifestPatched() {\\n    return MiddlewareManifest;\\n  };\\n}\\nif (NextNodeServerPatched?.prototype && typeof NextNodeServerPatched.prototype.logError === \\\"function\\\") {\\n  const openNextOriginalLogError = NextNodeServerPatched.prototype.logError;\\n  NextNodeServerPatched.prototype.logError = function logErrorPatched(...args) {\\n    try { console.error(...args); } catch {}\\n    return openNextOriginalLogError.apply(this, args);\\n  };\\n}\\n'; const out=src.slice(0, idx + needle.length) + insert + src.slice(idx + needle.length); fs.writeFileSync(indexFile,out,'utf8'); } } const handlerFile=path.join(root,'.open-next','server-functions','default','handler.mjs'); if(fs.existsSync(handlerFile)) { let handler=fs.readFileSync(handlerFile,'utf8'); if(!handler.includes('__OPENNEXT_MANIFEST_REQUIRE_PATCHED__')) { const manifestExpr=(p)=>JSON.stringify(JSON.parse(fs.readFileSync(p,'utf8'))); const middlewareExpr=manifestExpr(path.join(root,'.next','server','middleware-manifest.json')); const functionsExpr=manifestExpr(path.join(root,'.next','server','functions-config-manifest.json')); const pagesExpr=manifestExpr(path.join(root,'.next','server','pages-manifest.json')); const appPathsExpr=manifestExpr(path.join(root,'.next','server','app-paths-manifest.json')); const fontExpr=manifestExpr(path.join(root,'.next','server','next-font-manifest.json')); const serverRefExpr=manifestExpr(path.join(root,'.next','server','server-reference-manifest.json')); const routesExpr=manifestExpr(path.join(root,'.next','routes-manifest.json')); const buildExpr=manifestExpr(path.join(root,'.next','build-manifest.json')); const prerenderExpr=manifestExpr(path.join(root,'.next','prerender-manifest.json')); const loadableExpr=manifestExpr(path.join(root,'.next','react-loadable-manifest.json')); const requiredExpr=manifestExpr(path.join(root,'.next','required-server-files.json')); const appPathRoutesExpr=manifestExpr(path.join(root,'.next','app-path-routes-manifest.json')); const imagesExpr=manifestExpr(path.join(root,'.next','images-manifest.json')); const exportExpr=manifestExpr(path.join(root,'.next','export-marker.json')); const SQ=String.fromCharCode(39); const DQ=String.fromCharCode(34); const throwNeedle='throw Error(' + SQ + 'Dynamic require of ' + DQ + SQ + '+x+' + SQ + DQ + ' is not supported' + SQ + ')'; const inject='const __OPENNEXT_MANIFEST_REQUIRE_PATCHED__ = true; void __OPENNEXT_MANIFEST_REQUIRE_PATCHED__; ' + 'if (x === ' + SQ + '/.next/server/middleware-manifest.json' + SQ + ') return ' + middlewareExpr + '; ' + 'if (x === ' + SQ + '/.next/server/functions-config-manifest.json' + SQ + ') return ' + functionsExpr + '; ' + 'if (x === ' + SQ + '/.next/server/pages-manifest.json' + SQ + ') return ' + pagesExpr + '; ' + 'if (x === ' + SQ + '/.next/server/app-paths-manifest.json' + SQ + ') return ' + appPathsExpr + '; ' + 'if (x === ' + SQ + '/.next/server/next-font-manifest.json' + SQ + ') return ' + fontExpr + '; ' + 'if (x === ' + SQ + '/.next/server/server-reference-manifest.json' + SQ + ') return ' + serverRefExpr + '; ' + 'if (x === ' + SQ + '/.next/routes-manifest.json' + SQ + ') return ' + routesExpr + '; ' + 'if (x === ' + SQ + '/.next/build-manifest.json' + SQ + ') return ' + buildExpr + '; ' + 'if (x === ' + SQ + '/.next/prerender-manifest.json' + SQ + ') return ' + prerenderExpr + '; ' + 'if (x === ' + SQ + '/.next/react-loadable-manifest.json' + SQ + ') return ' + loadableExpr + '; ' + 'if (x === ' + SQ + '/.next/required-server-files.json' + SQ + ') return ' + requiredExpr + '; ' + 'if (x === ' + SQ + '/.next/app-path-routes-manifest.json' + SQ + ') return ' + appPathRoutesExpr + '; ' + 'if (x === ' + SQ + '/.next/images-manifest.json' + SQ + ') return ' + imagesExpr + '; ' + 'if (x === ' + SQ + '/.next/export-marker.json' + SQ + ') return ' + exportExpr + '; '; if(handler.indexOf(throwNeedle) < 0) { console.error('OpenNext require shim not found'); process.exit(1); } handler = handler.replace(throwNeedle, inject + throwNeedle); fs.writeFileSync(handlerFile,handler,'utf8'); } }\"",
    "cf:bundle": "pnpm run cf:build && wrangler deploy .open-next/worker.js --dry-run --outdir .open-next/.bundled && node -e \"const fs=require('node:fs'); const path=require('node:path'); const root=process.cwd(); const file=path.join(root,'.open-next','.bundled','worker.js'); let src=fs.readFileSync(file,'utf8'); const manifestExpr=(p)=>JSON.stringify(JSON.parse(fs.readFileSync(p,'utf8'))); const middlewareExpr=manifestExpr(path.join(root,'.next','server','middleware-manifest.json')); const functionsExpr=manifestExpr(path.join(root,'.next','server','functions-config-manifest.json')); const pagesExpr=manifestExpr(path.join(root,'.next','server','pages-manifest.json')); const appPathsExpr=manifestExpr(path.join(root,'.next','server','app-paths-manifest.json')); const fontExpr=manifestExpr(path.join(root,'.next','server','next-font-manifest.json')); const serverRefExpr=manifestExpr(path.join(root,'.next','server','server-reference-manifest.json')); const routesExpr=manifestExpr(path.join(root,'.next','routes-manifest.json')); const buildExpr=manifestExpr(path.join(root,'.next','build-manifest.json')); const prerenderExpr=manifestExpr(path.join(root,'.next','prerender-manifest.json')); const loadableExpr=manifestExpr(path.join(root,'.next','react-loadable-manifest.json')); const requiredExpr=manifestExpr(path.join(root,'.next','required-server-files.json')); const appPathRoutesExpr=manifestExpr(path.join(root,'.next','app-path-routes-manifest.json')); const imagesExpr=manifestExpr(path.join(root,'.next','images-manifest.json')); const exportExpr=manifestExpr(path.join(root,'.next','export-marker.json')); const SQ=String.fromCharCode(39); const DQ=String.fromCharCode(34); const NL=String.fromCharCode(10); const dotNext=path.join(root,'.next'); const serverAppDir=path.join(dotNext,'server','app'); const evalManifestEntries=[]; const toPosix=(p)=>p.split(path.sep).join('/'); const walkEvalManifests=(dir)=>{ for (const entry of fs.readdirSync(dir,{withFileTypes:true})) { const abs=path.join(dir,entry.name); if(entry.isDirectory()) walkEvalManifests(abs); else if(entry.isFile() && entry.name.endsWith('_client-reference-manifest.js')) { const endsWith=toPosix(path.relative(dotNext, abs)); const rel=toPosix(path.relative(serverAppDir, abs)); const key='/' + rel.replace('_client-reference-manifest.js',''); const code=fs.readFileSync(abs,'utf8'); evalManifestEntries.push({ endsWith, key, code }); } } }; if(fs.existsSync(serverAppDir)) walkEvalManifests(serverAppDir); const evalCases=evalManifestEntries.map(({endsWith,key,code})=> 'if (path22.endsWith(' + JSON.stringify(endsWith) + ')) { const __OPENNEXT_EVAL_MANIFEST_PATCHED__ = true; void __OPENNEXT_EVAL_MANIFEST_PATCHED__; (new Function(' + JSON.stringify(code) + '))(); return { __RSC_MANIFEST: { ' + JSON.stringify(key) + ': globalThis.__RSC_MANIFEST[' + JSON.stringify(key) + '], }, }; }').join(NL); const needle='throw Error(' + SQ + 'Dynamic require of ' + DQ + SQ + ' + x + ' + SQ + DQ + ' is not supported' + SQ + ');'; if(!src.includes(needle)) { console.error('Wrangler bundle require shim not found'); process.exit(1); } if(!src.includes('__OPENNEXT_WRANGLER_REQUIRE_PATCHED__')) { const inject='const __OPENNEXT_WRANGLER_REQUIRE_PATCHED__ = true; void __OPENNEXT_WRANGLER_REQUIRE_PATCHED__; ' + 'if (x === \\\"/.next/server/middleware-manifest.json\\\") return ' + middlewareExpr + '; ' + 'if (x === \\\"/.next/server/functions-config-manifest.json\\\") return ' + functionsExpr + '; ' + 'if (x === \\\"/.next/server/pages-manifest.json\\\") return ' + pagesExpr + '; ' + 'if (x === \\\"/.next/server/app-paths-manifest.json\\\") return ' + appPathsExpr + '; ' + 'if (x === \\\"/.next/server/next-font-manifest.json\\\") return ' + fontExpr + '; ' + 'if (x === \\\"/.next/server/server-reference-manifest.json\\\") return ' + serverRefExpr + '; ' + 'if (x === \\\"/.next/routes-manifest.json\\\") return ' + routesExpr + '; ' + 'if (x === \\\"/.next/build-manifest.json\\\") return ' + buildExpr + '; ' + 'if (x === \\\"/.next/prerender-manifest.json\\\") return ' + prerenderExpr + '; ' + 'if (x === \\\"/.next/react-loadable-manifest.json\\\") return ' + loadableExpr + '; ' + 'if (x === \\\"/.next/required-server-files.json\\\") return ' + requiredExpr + '; ' + 'if (x === \\\"/.next/app-path-routes-manifest.json\\\") return ' + appPathRoutesExpr + '; ' + 'if (x === \\\"/.next/images-manifest.json\\\") return ' + imagesExpr + '; ' + 'if (x === \\\"/.next/export-marker.json\\\") return ' + exportExpr + '; '; src = src.split(needle).join(inject + needle); } if(!src.includes('__OPENNEXT_WORKER_ERROR_PATCHED__')) { const tailNeedle='return handler4(reqOrResp, env2, ctx, request3.signal);' + NL + '    });'; if(!src.includes(tailNeedle)) { console.error('OpenNext worker fetch tail not found'); process.exit(1); } const tailInject='process.env.OPENNEXT_DEBUG_STACK = (env2 && env2.OPENNEXT_DEBUG_STACK) ? String(env2.OPENNEXT_DEBUG_STACK) : \\\"\\\";' + NL + '    const serverResponse = await handler4(reqOrResp, env2, ctx, request3.signal);' + NL + '    const __OPENNEXT_SERVER_STAGE_HEADER_PATCHED__ = true; void __OPENNEXT_SERVER_STAGE_HEADER_PATCHED__; const responseHeaders = new Headers(serverResponse.headers); responseHeaders.set(\\\"x-open-next-stage\\\", \\\"server\\\"); responseHeaders.set(\\\"x-open-next-debug-stack\\\", String(process.env.OPENNEXT_DEBUG_STACK || \\\"\\\")); return new Response(serverResponse.body, { status: serverResponse.status, statusText: serverResponse.statusText, headers: responseHeaders });' + NL + '    }).catch((err) => { const __OPENNEXT_WORKER_ERROR_PATCHED__ = true; void __OPENNEXT_WORKER_ERROR_PATCHED__; console.error(err); const body = (env2 && env2.OPENNEXT_DEBUG_STACK === \\\"true\\\") ? ((err && err.stack) ? err.stack : String(err)) : \\\"Internal Server Error\\\"; return new Response(body, { status: 500, headers: { \\\"content-type\\\": \\\"text/plain\\\", \\\"x-open-next-stage\\\": \\\"server-error\\\", \\\"x-open-next-caught\\\": \\\"1\\\" } }); });'; src = src.replace(tailNeedle, tailInject); } if(!src.includes('__OPENNEXT_STAGE_HEADER_PATCHED__')) { const stageNeedle='if (reqOrResp instanceof Response) {' + NL + '        return reqOrResp;' + NL + '      }'; if(!src.includes(stageNeedle)) { console.error('OpenNext stage probe not found'); process.exit(1); } const stageInject='if (reqOrResp instanceof Response) {' + NL + '        const __OPENNEXT_STAGE_HEADER_PATCHED__ = true; void __OPENNEXT_STAGE_HEADER_PATCHED__; const headers = new Headers(reqOrResp.headers); headers.set(\\\"x-open-next-stage\\\", \\\"middleware\\\"); return new Response(reqOrResp.body, { status: reqOrResp.status, statusText: reqOrResp.statusText, headers });' + NL + '      }'; src = src.replace(stageNeedle, stageInject); } if(!src.includes('__OPENNEXT_DEBUG_RETHROW_PATCHED__')) { const baseNeedle='this.logError((0, _iserror.getProperError)(err)), res.statusCode = 500, res.body(\\\"Internal Server Error\\\").send();'; if(!src.includes(baseNeedle)) { console.error('OpenNext BaseServer catch not found'); process.exit(1); } const baseInject='if (process.env.OPENNEXT_DEBUG_STACK === \\\"true\\\") { const __OPENNEXT_DEBUG_RETHROW_PATCHED__ = true; void __OPENNEXT_DEBUG_RETHROW_PATCHED__; throw err; } ' + baseNeedle; src = src.replace(baseNeedle, baseInject); const processRequestNeedle='} catch (e) {' + NL + '    e.constructor.name === \\\"NoFallbackError\\\" ? await handleNoFallbackError(req, res, routingResult, requestMetadata) : (error7(\\\"NextJS request failed.\\\", e), await tryRenderError(\\\"500\\\", res, routingResult.internalEvent));'; if(!src.includes(processRequestNeedle)) { console.error('OpenNext processRequest catch not found'); process.exit(1); } const processRequestInject='} catch (e) {' + NL + '    const __OPENNEXT_DEBUG_RETHROW_PROCESSREQUEST_PATCHED__ = true; void __OPENNEXT_DEBUG_RETHROW_PROCESSREQUEST_PATCHED__; if (process.env.OPENNEXT_DEBUG_STACK === \\\"true\\\") throw e;' + NL + '    e.constructor.name === \\\"NoFallbackError\\\" ? await handleNoFallbackError(req, res, routingResult, requestMetadata) : (error7(\\\"NextJS request failed.\\\", e), await tryRenderError(\\\"500\\\", res, routingResult.internalEvent));'; src = src.replace(processRequestNeedle, processRequestInject); const noFallbackNeedle='} catch (e) {' + NL + '    e.constructor.name === \\\"NoFallbackError\\\" ? await handleNoFallbackError(req, res, routingResult, metadata, index + 1) : (error7(\\\"NextJS request failed.\\\", e), await tryRenderError(\\\"500\\\", res, routingResult.internalEvent));'; if(!src.includes(noFallbackNeedle)) { console.error('OpenNext handleNoFallbackError catch not found'); process.exit(1); } const noFallbackInject='} catch (e) {' + NL + '    const __OPENNEXT_DEBUG_RETHROW_NOFALLBACK_PATCHED__ = true; void __OPENNEXT_DEBUG_RETHROW_NOFALLBACK_PATCHED__; if (process.env.OPENNEXT_DEBUG_STACK === \\\"true\\\") throw e;' + NL + '    e.constructor.name === \\\"NoFallbackError\\\" ? await handleNoFallbackError(req, res, routingResult, metadata, index + 1) : (error7(\\\"NextJS request failed.\\\", e), await tryRenderError(\\\"500\\\", res, routingResult.internalEvent));'; src = src.replace(noFallbackNeedle, noFallbackInject); const tryRenderNeedle='} catch (e) {' + NL + '    error7(\\\"NextJS request failed.\\\", e), res.statusCode = 500, res.setHeader(\\\"Content-Type\\\", \\\"application/json\\\"), res.end(JSON.stringify({ message: \\\"Server failed to respond.\\\", details: e }, null, 2));'; if(!src.includes(tryRenderNeedle)) { console.error('OpenNext tryRenderError catch not found'); process.exit(1); } const tryRenderInject='} catch (e) {' + NL + '    const __OPENNEXT_DEBUG_RETHROW_TRYRENDER_PATCHED__ = true; void __OPENNEXT_DEBUG_RETHROW_TRYRENDER_PATCHED__; if (process.env.OPENNEXT_DEBUG_STACK === \\\"true\\\") throw e;' + NL + '    error7(\\\"NextJS request failed.\\\", e), res.statusCode = 500, res.setHeader(\\\"Content-Type\\\", \\\"application/json\\\"), res.end(JSON.stringify({ message: \\\"Server failed to respond.\\\", details: e }, null, 2));'; src = src.replace(tryRenderNeedle, tryRenderInject); } if(!src.includes('__OPENNEXT_EVAL_MANIFEST_PATCHED__') && evalManifestEntries.length > 0) { const evalNeedle='throw path22 = path22.replaceAll(' + DQ + '/' + DQ + ', ' + DQ + '/' + DQ + '), new Error(`Unexpected evalManifest(${path22}) call!`);'; if(!src.includes(evalNeedle)) { console.error('OpenNext evalManifest throw not found'); process.exit(1); } const evalInject='path22 = path22.replaceAll(' + DQ + '/' + DQ + ', ' + DQ + '/' + DQ + ');' + NL + evalCases + NL + 'throw new Error(`Unexpected evalManifest(${path22}) call!`);'; src = src.replace(evalNeedle, evalInject); } fs.writeFileSync(file,src,'utf8');\"",
    "cf:preview": "pnpm run preview",
    "cf:deploy": "pnpm run deploy",
    "lint": "eslint",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "setup:hcs2-topics": "tsx scripts/setup-hcs2-topics.ts"
  },
  "dependencies": {
    "@hashgraph/proto": "^2.25.0",
    "@hashgraph/sdk": "^2.78.0",
    "@hashgraph/hedera-wallet-connect": "2.0.4",
    "@hashgraphonline/hashinal-wc": "2.0.18",
    "@hashgraphonline/standards-sdk": "0.1.144",
    "@kiloscribe/inscription-sdk": "2.0.8",
    "@radix-ui/react-slot": "^1.2.4",
    "axios": "^1.13.2",
    "bs58": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.6.1",
    "dotenv-flow": "^4.1.0",
    "next": "16.0.10",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-icons": "^5.5.0",
    "swr": "^2.3.7",
    "tailwind-merge": "^3.4.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@opennextjs/cloudflare": "^1.14.6",
    "@tailwindcss/postcss": "^4.1.18",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^20.19.26",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@types/webpack": "^5.28.5",
    "@vitest/coverage-v8": "^4.0.15",
    "esbuild": "^0.27.1",
    "eslint": "^9.39.1",
    "eslint-config-next": "16.0.8",
    "jsdom": "^27.3.0",
    "node-polyfill-webpack-plugin": "^4.1.0",
    "patch-package": "^8.0.1",
    "tailwindcss": "^4.1.18",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3",
    "vitest": "^4.0.15",
    "wrangler": "^4.54.0"
  },
  "exports": {
    "./config/env": "./config/env.js"
  },
  "overrides": {
    "sharp": "0.33.4",
    "@xenova/transformers": {
      "sharp": "0.33.4"
    },
    "@hashgraphonline/hashinal-wc": "2.0.18",
    "@hashgraphonline/standards-sdk": "0.1.144",
    "@reown/appkit": "1.8.15",
    "@reown/appkit-controllers": "1.8.15",
    "@hashgraph/hedera-wallet-connect": "2.0.4"
  },
  "pnpm": {
    "overrides": {
      "@hashgraphonline/hashinal-wc": "2.0.18",
      "@hashgraphonline/standards-sdk": "0.1.144",
      "@reown/appkit": "1.8.15",
      "@reown/appkit-controllers": "1.8.15",
      "@hashgraph/hedera-wallet-connect": "2.0.4",
      "ipfs-http-client>parse-duration": "2.1.3",
      "ipfs-core-utils>parse-duration": "2.1.3",
      "ipfs-core-utils>nanoid": "5.0.9",
      "interface-datastore>nanoid": "5.0.9"
    }
  },
  "packageManager": "pnpm@10.17.0+sha512.fce8a3dd29a4ed2ec566fb53efbb04d8c44a0f05bc6f24a73046910fb9c3ce7afa35a0980500668fa3573345bd644644fa98338fa168235c80f4aa17aa17fbef"
}
